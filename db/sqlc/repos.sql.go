// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: repos.sql

package sqlc

import (
	"context"
	"database/sql"
)

const deleteReposByOwner = `-- name: DeleteReposByOwner :exec
DELETE FROM agg_repo
WHERE owner = $1
`

func (q *Queries) DeleteReposByOwner(ctx context.Context, owner string) error {
	_, err := q.db.ExecContext(ctx, deleteReposByOwner, owner)
	return err
}

const deleteReposByOwnerBefore = `-- name: DeleteReposByOwnerBefore :execrows
DELETE FROM agg_repo
WHERE owner = $1
  AND refreshed_at < $2
`

type DeleteReposByOwnerBeforeParams struct {
	Owner       string       `json:"owner"`
	RefreshedAt sql.NullTime `json:"refreshed_at"`
}

func (q *Queries) DeleteReposByOwnerBefore(ctx context.Context, arg DeleteReposByOwnerBeforeParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteReposByOwnerBefore, arg.Owner, arg.RefreshedAt)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const insertRepo = `-- name: InsertRepo :exec
INSERT INTO agg_repo (
    owner,
    name,
    description,
    language,
    homepage,
    forks_count,
    network_count,
    open_issues_count,
    stargazers_count,
    subscribers_count,
    watchers_count,
    size,
    fork,
    default_branch,
    master_branch,
    created_at,
    pushed_at,
    updated_at,
    refreshed_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10,
    $11, $12, $13, $14, $15, $16, $17, $18, $19
)
`

type InsertRepoParams struct {
	Owner            string         `json:"owner"`
	Name             string         `json:"name"`
	Description      sql.NullString `json:"description"`
	Language         sql.NullString `json:"language"`
	Homepage         sql.NullString `json:"homepage"`
	ForksCount       sql.NullInt32  `json:"forks_count"`
	NetworkCount     sql.NullInt32  `json:"network_count"`
	OpenIssuesCount  sql.NullInt32  `json:"open_issues_count"`
	StargazersCount  sql.NullInt32  `json:"stargazers_count"`
	SubscribersCount sql.NullInt32  `json:"subscribers_count"`
	WatchersCount    sql.NullInt32  `json:"watchers_count"`
	Size             sql.NullInt32  `json:"size"`
	Fork             sql.NullBool   `json:"fork"`
	DefaultBranch    sql.NullString `json:"default_branch"`
	MasterBranch     sql.NullString `json:"master_branch"`
	CreatedAt        sql.NullTime   `json:"created_at"`
	PushedAt         sql.NullTime   `json:"pushed_at"`
	UpdatedAt        sql.NullTime   `json:"updated_at"`
	RefreshedAt      sql.NullTime   `json:"refreshed_at"`
}

func (q *Queries) InsertRepo(ctx context.Context, arg InsertRepoParams) error {
	_, err := q.db.ExecContext(ctx, insertRepo,
		arg.Owner,
		arg.Name,
		arg.Description,
		arg.Language,
		arg.Homepage,
		arg.ForksCount,
		arg.NetworkCount,
		arg.OpenIssuesCount,
		arg.StargazersCount,
		arg.SubscribersCount,
		arg.WatchersCount,
		arg.Size,
		arg.Fork,
		arg.DefaultBranch,
		arg.MasterBranch,
		arg.CreatedAt,
		arg.PushedAt,
		arg.UpdatedAt,
		arg.RefreshedAt,
	)
	return err
}

const languageLeaders = `-- name: LanguageLeaders :many
WITH ranked_repos AS (
    SELECT
        r1.owner,
        r1.name,
        r1.description,
        r1.forks_count,
        r1.stargazers_count,
        r1.watchers_count,
        r1.fork,
        (
            SELECT SUM(stargazers_count)
            FROM agg_repo
            WHERE LOWER(language) = LOWER($1)
              AND owner = r1.owner
        ) AS total_stars,
        ROW_NUMBER() OVER (PARTITION BY r1.owner ORDER BY r1.stargazers_count DESC) AS rownum
    FROM agg_repo AS r1
    WHERE LOWER(r1.language) = LOWER($1)
)
SELECT
    ranked_repos.owner,
    ranked_repos.name,
    COALESCE(ranked_repos.description, '')::text AS description,
    COALESCE(ranked_repos.forks_count, 0)::int AS forks_count,
    COALESCE(ranked_repos.stargazers_count, 0)::int AS stargazers_count,
    COALESCE(ranked_repos.watchers_count, 0)::int AS watchers_count,
    COALESCE(ranked_repos.fork, false)::bool AS fork,
    ranked_repos.total_stars,
    ranked_repos.rownum,
    COALESCE(agg_user.name, '')::text AS display_name,
    COALESCE(agg_user.type, '')::text AS type
FROM ranked_repos
JOIN agg_user ON agg_user.login = ranked_repos.owner
WHERE ranked_repos.rownum < 4
ORDER BY ranked_repos.total_stars DESC, ranked_repos.owner, ranked_repos.stargazers_count DESC
`

type LanguageLeadersRow struct {
	Owner           string `json:"owner"`
	Name            string `json:"name"`
	Description     string `json:"description"`
	ForksCount      int32  `json:"forks_count"`
	StargazersCount int32  `json:"stargazers_count"`
	WatchersCount   int32  `json:"watchers_count"`
	Fork            bool   `json:"fork"`
	TotalStars      int64  `json:"total_stars"`
	Rownum          int64  `json:"rownum"`
	DisplayName     string `json:"display_name"`
	Type            string `json:"type"`
}

func (q *Queries) LanguageLeaders(ctx context.Context, lower string) ([]LanguageLeadersRow, error) {
	rows, err := q.db.QueryContext(ctx, languageLeaders, lower)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LanguageLeadersRow
	for rows.Next() {
		var i LanguageLeadersRow
		if err := rows.Scan(
			&i.Owner,
			&i.Name,
			&i.Description,
			&i.ForksCount,
			&i.StargazersCount,
			&i.WatchersCount,
			&i.Fork,
			&i.TotalStars,
			&i.Rownum,
			&i.DisplayName,
			&i.Type,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const popularLanguages = `-- name: PopularLanguages :many
SELECT
    COALESCE(language, '')::text AS language,
    COUNT(*) AS count,
    COUNT(DISTINCT owner) AS users
FROM agg_repo
WHERE language IS NOT NULL
  AND fork = FALSE
GROUP BY language
ORDER BY count DESC
LIMIT 50
`

type PopularLanguagesRow struct {
	Language string `json:"language"`
	Count    int64  `json:"count"`
	Users    int64  `json:"users"`
}

func (q *Queries) PopularLanguages(ctx context.Context) ([]PopularLanguagesRow, error) {
	rows, err := q.db.QueryContext(ctx, popularLanguages)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PopularLanguagesRow
	for rows.Next() {
		var i PopularLanguagesRow
		if err := rows.Scan(&i.Language, &i.Count, &i.Users); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const reposForUser = `-- name: ReposForUser :many
SELECT
    owner,
    name,
    COALESCE(description, '')::text AS description,
    COALESCE(language, '')::text AS language,
    COALESCE(homepage, '')::text AS homepage,
    COALESCE(forks_count, 0)::int AS forks_count,
    COALESCE(network_count, 0)::int AS network_count,
    COALESCE(open_issues_count, 0)::int AS open_issues_count,
    COALESCE(stargazers_count, 0)::int AS stargazers_count,
    COALESCE(subscribers_count, 0)::int AS subscribers_count,
    COALESCE(watchers_count, 0)::int AS watchers_count,
    COALESCE(size, 0)::int AS size,
    COALESCE(fork, false)::bool AS fork,
    COALESCE(default_branch, '')::text AS default_branch,
    COALESCE(master_branch, '')::text AS master_branch,
    created_at,
    pushed_at,
    updated_at,
    refreshed_at
FROM agg_repo
WHERE LOWER(owner) = LOWER($1)
ORDER BY language, stargazers_count DESC, name
`

type ReposForUserRow struct {
	Owner            string       `json:"owner"`
	Name             string       `json:"name"`
	Description      string       `json:"description"`
	Language         string       `json:"language"`
	Homepage         string       `json:"homepage"`
	ForksCount       int32        `json:"forks_count"`
	NetworkCount     int32        `json:"network_count"`
	OpenIssuesCount  int32        `json:"open_issues_count"`
	StargazersCount  int32        `json:"stargazers_count"`
	SubscribersCount int32        `json:"subscribers_count"`
	WatchersCount    int32        `json:"watchers_count"`
	Size             int32        `json:"size"`
	Fork             bool         `json:"fork"`
	DefaultBranch    string       `json:"default_branch"`
	MasterBranch     string       `json:"master_branch"`
	CreatedAt        sql.NullTime `json:"created_at"`
	PushedAt         sql.NullTime `json:"pushed_at"`
	UpdatedAt        sql.NullTime `json:"updated_at"`
	RefreshedAt      sql.NullTime `json:"refreshed_at"`
}

func (q *Queries) ReposForUser(ctx context.Context, lower string) ([]ReposForUserRow, error) {
	rows, err := q.db.QueryContext(ctx, reposForUser, lower)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ReposForUserRow
	for rows.Next() {
		var i ReposForUserRow
		if err := rows.Scan(
			&i.Owner,
			&i.Name,
			&i.Description,
			&i.Language,
			&i.Homepage,
			&i.ForksCount,
			&i.NetworkCount,
			&i.OpenIssuesCount,
			&i.StargazersCount,
			&i.SubscribersCount,
			&i.WatchersCount,
			&i.Size,
			&i.Fork,
			&i.DefaultBranch,
			&i.MasterBranch,
			&i.CreatedAt,
			&i.PushedAt,
			&i.UpdatedAt,
			&i.RefreshedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchRepos = `-- name: SearchRepos :many
SELECT
    owner,
    name,
    COALESCE(description, '')::text AS description,
    COALESCE(language, '')::text AS language,
    COALESCE(homepage, '')::text AS homepage,
    COALESCE(forks_count, 0)::int AS forks_count,
    COALESCE(network_count, 0)::int AS network_count,
    COALESCE(open_issues_count, 0)::int AS open_issues_count,
    COALESCE(stargazers_count, 0)::int AS stargazers_count,
    COALESCE(subscribers_count, 0)::int AS subscribers_count,
    COALESCE(watchers_count, 0)::int AS watchers_count,
    COALESCE(size, 0)::int AS size,
    COALESCE(fork, false)::bool AS fork,
    COALESCE(default_branch, '')::text AS default_branch,
    COALESCE(master_branch, '')::text AS master_branch,
    created_at,
    pushed_at,
    updated_at,
    refreshed_at
FROM agg_repo
WHERE LOWER(name) LIKE LOWER($1)
   OR LOWER(description) LIKE LOWER($1)
ORDER BY stargazers_count DESC
LIMIT 50
`

type SearchReposRow struct {
	Owner            string       `json:"owner"`
	Name             string       `json:"name"`
	Description      string       `json:"description"`
	Language         string       `json:"language"`
	Homepage         string       `json:"homepage"`
	ForksCount       int32        `json:"forks_count"`
	NetworkCount     int32        `json:"network_count"`
	OpenIssuesCount  int32        `json:"open_issues_count"`
	StargazersCount  int32        `json:"stargazers_count"`
	SubscribersCount int32        `json:"subscribers_count"`
	WatchersCount    int32        `json:"watchers_count"`
	Size             int32        `json:"size"`
	Fork             bool         `json:"fork"`
	DefaultBranch    string       `json:"default_branch"`
	MasterBranch     string       `json:"master_branch"`
	CreatedAt        sql.NullTime `json:"created_at"`
	PushedAt         sql.NullTime `json:"pushed_at"`
	UpdatedAt        sql.NullTime `json:"updated_at"`
	RefreshedAt      sql.NullTime `json:"refreshed_at"`
}

func (q *Queries) SearchRepos(ctx context.Context, lower string) ([]SearchReposRow, error) {
	rows, err := q.db.QueryContext(ctx, searchRepos, lower)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchReposRow
	for rows.Next() {
		var i SearchReposRow
		if err := rows.Scan(
			&i.Owner,
			&i.Name,
			&i.Description,
			&i.Language,
			&i.Homepage,
			&i.ForksCount,
			&i.NetworkCount,
			&i.OpenIssuesCount,
			&i.StargazersCount,
			&i.SubscribersCount,
			&i.WatchersCount,
			&i.Size,
			&i.Fork,
			&i.DefaultBranch,
			&i.MasterBranch,
			&i.CreatedAt,
			&i.PushedAt,
			&i.UpdatedAt,
			&i.RefreshedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRepo = `-- name: UpdateRepo :execrows
UPDATE agg_repo
SET
    owner = $1,
    name = $2,
    description = $3,
    language = $4,
    homepage = $5,
    forks_count = $6,
    network_count = $7,
    open_issues_count = $8,
    stargazers_count = $9,
    subscribers_count = $10,
    watchers_count = $11,
    size = $12,
    fork = $13,
    default_branch = $14,
    master_branch = $15,
    created_at = $16,
    pushed_at = $17,
    updated_at = $18,
    refreshed_at = $19
WHERE owner = $1 AND name = $2
`

type UpdateRepoParams struct {
	Owner            string         `json:"owner"`
	Name             string         `json:"name"`
	Description      sql.NullString `json:"description"`
	Language         sql.NullString `json:"language"`
	Homepage         sql.NullString `json:"homepage"`
	ForksCount       sql.NullInt32  `json:"forks_count"`
	NetworkCount     sql.NullInt32  `json:"network_count"`
	OpenIssuesCount  sql.NullInt32  `json:"open_issues_count"`
	StargazersCount  sql.NullInt32  `json:"stargazers_count"`
	SubscribersCount sql.NullInt32  `json:"subscribers_count"`
	WatchersCount    sql.NullInt32  `json:"watchers_count"`
	Size             sql.NullInt32  `json:"size"`
	Fork             sql.NullBool   `json:"fork"`
	DefaultBranch    sql.NullString `json:"default_branch"`
	MasterBranch     sql.NullString `json:"master_branch"`
	CreatedAt        sql.NullTime   `json:"created_at"`
	PushedAt         sql.NullTime   `json:"pushed_at"`
	UpdatedAt        sql.NullTime   `json:"updated_at"`
	RefreshedAt      sql.NullTime   `json:"refreshed_at"`
}

func (q *Queries) UpdateRepo(ctx context.Context, arg UpdateRepoParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateRepo,
		arg.Owner,
		arg.Name,
		arg.Description,
		arg.Language,
		arg.Homepage,
		arg.ForksCount,
		arg.NetworkCount,
		arg.OpenIssuesCount,
		arg.StargazersCount,
		arg.SubscribersCount,
		arg.WatchersCount,
		arg.Size,
		arg.Fork,
		arg.DefaultBranch,
		arg.MasterBranch,
		arg.CreatedAt,
		arg.PushedAt,
		arg.UpdatedAt,
		arg.RefreshedAt,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}
