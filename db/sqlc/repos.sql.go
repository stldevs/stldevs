// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: repos.sql

package sqlc

import (
	"context"
	"database/sql"
)

const deleteReposByOwner = `-- name: DeleteReposByOwner :exec
DELETE FROM agg_repo
WHERE owner = $1
`

func (q *Queries) DeleteReposByOwner(ctx context.Context, owner string) error {
	_, err := q.db.ExecContext(ctx, deleteReposByOwner, owner)
	return err
}

const deleteReposByOwnerBefore = `-- name: DeleteReposByOwnerBefore :execrows
DELETE FROM agg_repo
WHERE owner = $1
  AND refreshed_at < $2
`

type DeleteReposByOwnerBeforeParams struct {
	Owner       string
	RefreshedAt sql.NullTime
}

func (q *Queries) DeleteReposByOwnerBefore(ctx context.Context, arg DeleteReposByOwnerBeforeParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteReposByOwnerBefore, arg.Owner, arg.RefreshedAt)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const insertRepo = `-- name: InsertRepo :exec
INSERT INTO agg_repo (
    owner,
    name,
    description,
    language,
    homepage,
    forks_count,
    network_count,
    open_issues_count,
    stargazers_count,
    subscribers_count,
    watchers_count,
    size,
    fork,
    default_branch,
    master_branch,
    created_at,
    pushed_at,
    updated_at,
    refreshed_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10,
    $11, $12, $13, $14, $15, $16, $17, $18, $19
)
`

type InsertRepoParams struct {
	Owner            string
	Name             string
	Description      sql.NullString
	Language         sql.NullString
	Homepage         sql.NullString
	ForksCount       sql.NullInt32
	NetworkCount     sql.NullInt32
	OpenIssuesCount  sql.NullInt32
	StargazersCount  sql.NullInt32
	SubscribersCount sql.NullInt32
	WatchersCount    sql.NullInt32
	Size             sql.NullInt32
	Fork             sql.NullBool
	DefaultBranch    sql.NullString
	MasterBranch     sql.NullString
	CreatedAt        sql.NullTime
	PushedAt         sql.NullTime
	UpdatedAt        sql.NullTime
	RefreshedAt      sql.NullTime
}

func (q *Queries) InsertRepo(ctx context.Context, arg InsertRepoParams) error {
	_, err := q.db.ExecContext(ctx, insertRepo,
		arg.Owner,
		arg.Name,
		arg.Description,
		arg.Language,
		arg.Homepage,
		arg.ForksCount,
		arg.NetworkCount,
		arg.OpenIssuesCount,
		arg.StargazersCount,
		arg.SubscribersCount,
		arg.WatchersCount,
		arg.Size,
		arg.Fork,
		arg.DefaultBranch,
		arg.MasterBranch,
		arg.CreatedAt,
		arg.PushedAt,
		arg.UpdatedAt,
		arg.RefreshedAt,
	)
	return err
}

const languageLeaders = `-- name: LanguageLeaders :many
WITH ranked_repos AS (
    SELECT
        r1.owner,
        r1.name,
        r1.description,
        r1.forks_count,
        r1.stargazers_count,
        r1.watchers_count,
        r1.fork,
        (
            SELECT SUM(stargazers_count)
            FROM agg_repo
            WHERE LOWER(language) = LOWER($1)
              AND owner = r1.owner
        ) AS total_stars,
        ROW_NUMBER() OVER (PARTITION BY r1.owner ORDER BY r1.stargazers_count DESC) AS rownum
    FROM agg_repo AS r1
    WHERE LOWER(r1.language) = LOWER($1)
)
SELECT
    ranked_repos.owner,
    ranked_repos.name,
    ranked_repos.description,
    ranked_repos.forks_count,
    ranked_repos.stargazers_count,
    ranked_repos.watchers_count,
    ranked_repos.fork,
    ranked_repos.total_stars,
    ranked_repos.rownum,
    agg_user.name AS display_name,
    agg_user.type
FROM ranked_repos
JOIN agg_user ON agg_user.login = ranked_repos.owner
WHERE ranked_repos.rownum < 4
ORDER BY ranked_repos.total_stars DESC, ranked_repos.owner, ranked_repos.stargazers_count DESC
`

type LanguageLeadersRow struct {
	Owner           string
	Name            string
	Description     sql.NullString
	ForksCount      sql.NullInt32
	StargazersCount sql.NullInt32
	WatchersCount   sql.NullInt32
	Fork            sql.NullBool
	TotalStars      int64
	Rownum          int64
	DisplayName     sql.NullString
	Type            sql.NullString
}

func (q *Queries) LanguageLeaders(ctx context.Context, lower string) ([]LanguageLeadersRow, error) {
	rows, err := q.db.QueryContext(ctx, languageLeaders, lower)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LanguageLeadersRow
	for rows.Next() {
		var i LanguageLeadersRow
		if err := rows.Scan(
			&i.Owner,
			&i.Name,
			&i.Description,
			&i.ForksCount,
			&i.StargazersCount,
			&i.WatchersCount,
			&i.Fork,
			&i.TotalStars,
			&i.Rownum,
			&i.DisplayName,
			&i.Type,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const popularLanguages = `-- name: PopularLanguages :many
SELECT
    language,
    COUNT(*) AS repo_count,
    COUNT(DISTINCT owner) AS user_count
FROM agg_repo
WHERE language IS NOT NULL
  AND fork = FALSE
GROUP BY language
ORDER BY repo_count DESC
LIMIT 50
`

type PopularLanguagesRow struct {
	Language  sql.NullString
	RepoCount int64
	UserCount int64
}

func (q *Queries) PopularLanguages(ctx context.Context) ([]PopularLanguagesRow, error) {
	rows, err := q.db.QueryContext(ctx, popularLanguages)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PopularLanguagesRow
	for rows.Next() {
		var i PopularLanguagesRow
		if err := rows.Scan(&i.Language, &i.RepoCount, &i.UserCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const reposForUser = `-- name: ReposForUser :many
SELECT owner, name, description, language, homepage, forks_count, network_count, open_issues_count, stargazers_count, subscribers_count, watchers_count, size, fork, default_branch, master_branch, created_at, pushed_at, updated_at, refreshed_at
FROM agg_repo
WHERE LOWER(owner) = LOWER($1)
ORDER BY language, stargazers_count DESC, name
`

func (q *Queries) ReposForUser(ctx context.Context, lower string) ([]AggRepo, error) {
	rows, err := q.db.QueryContext(ctx, reposForUser, lower)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AggRepo
	for rows.Next() {
		var i AggRepo
		if err := rows.Scan(
			&i.Owner,
			&i.Name,
			&i.Description,
			&i.Language,
			&i.Homepage,
			&i.ForksCount,
			&i.NetworkCount,
			&i.OpenIssuesCount,
			&i.StargazersCount,
			&i.SubscribersCount,
			&i.WatchersCount,
			&i.Size,
			&i.Fork,
			&i.DefaultBranch,
			&i.MasterBranch,
			&i.CreatedAt,
			&i.PushedAt,
			&i.UpdatedAt,
			&i.RefreshedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchRepos = `-- name: SearchRepos :many
SELECT owner, name, description, language, homepage, forks_count, network_count, open_issues_count, stargazers_count, subscribers_count, watchers_count, size, fork, default_branch, master_branch, created_at, pushed_at, updated_at, refreshed_at
FROM agg_repo
WHERE LOWER(name) LIKE LOWER($1)
   OR LOWER(description) LIKE LOWER($1)
ORDER BY stargazers_count DESC
LIMIT 100
`

func (q *Queries) SearchRepos(ctx context.Context, lower string) ([]AggRepo, error) {
	rows, err := q.db.QueryContext(ctx, searchRepos, lower)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AggRepo
	for rows.Next() {
		var i AggRepo
		if err := rows.Scan(
			&i.Owner,
			&i.Name,
			&i.Description,
			&i.Language,
			&i.Homepage,
			&i.ForksCount,
			&i.NetworkCount,
			&i.OpenIssuesCount,
			&i.StargazersCount,
			&i.SubscribersCount,
			&i.WatchersCount,
			&i.Size,
			&i.Fork,
			&i.DefaultBranch,
			&i.MasterBranch,
			&i.CreatedAt,
			&i.PushedAt,
			&i.UpdatedAt,
			&i.RefreshedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRepo = `-- name: UpdateRepo :execrows
UPDATE agg_repo
SET
    owner = $1,
    name = $2,
    description = $3,
    language = $4,
    homepage = $5,
    forks_count = $6,
    network_count = $7,
    open_issues_count = $8,
    stargazers_count = $9,
    subscribers_count = $10,
    watchers_count = $11,
    size = $12,
    fork = $13,
    default_branch = $14,
    master_branch = $15,
    created_at = $16,
    pushed_at = $17,
    updated_at = $18,
    refreshed_at = $19
WHERE owner = $1 AND name = $2
`

type UpdateRepoParams struct {
	Owner            string
	Name             string
	Description      sql.NullString
	Language         sql.NullString
	Homepage         sql.NullString
	ForksCount       sql.NullInt32
	NetworkCount     sql.NullInt32
	OpenIssuesCount  sql.NullInt32
	StargazersCount  sql.NullInt32
	SubscribersCount sql.NullInt32
	WatchersCount    sql.NullInt32
	Size             sql.NullInt32
	Fork             sql.NullBool
	DefaultBranch    sql.NullString
	MasterBranch     sql.NullString
	CreatedAt        sql.NullTime
	PushedAt         sql.NullTime
	UpdatedAt        sql.NullTime
	RefreshedAt      sql.NullTime
}

func (q *Queries) UpdateRepo(ctx context.Context, arg UpdateRepoParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateRepo,
		arg.Owner,
		arg.Name,
		arg.Description,
		arg.Language,
		arg.Homepage,
		arg.ForksCount,
		arg.NetworkCount,
		arg.OpenIssuesCount,
		arg.StargazersCount,
		arg.SubscribersCount,
		arg.WatchersCount,
		arg.Size,
		arg.Fork,
		arg.DefaultBranch,
		arg.MasterBranch,
		arg.CreatedAt,
		arg.PushedAt,
		arg.UpdatedAt,
		arg.RefreshedAt,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}
