// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: users.sql

package sqlc

import (
	"context"
	"database/sql"
)

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM agg_user
WHERE login = $1
`

func (q *Queries) DeleteUser(ctx context.Context, login string) error {
	_, err := q.db.ExecContext(ctx, deleteUser, login)
	return err
}

const getUser = `-- name: GetUser :one
SELECT
    login,
    email,
    name,
    location,
    hireable,
    blog,
    bio,
    followers,
    following,
    public_repos,
    public_gists,
    avatar_url,
    type,
    disk_usage,
    created_at,
    updated_at,
    company,
    hide,
    is_admin
FROM agg_user
WHERE login = $1
`

type GetUserRow struct {
	Login       string
	Email       sql.NullString
	Name        sql.NullString
	Location    sql.NullString
	Hireable    sql.NullBool
	Blog        sql.NullString
	Bio         sql.NullString
	Followers   sql.NullInt32
	Following   sql.NullInt32
	PublicRepos sql.NullInt32
	PublicGists sql.NullInt32
	AvatarUrl   sql.NullString
	Type        sql.NullString
	DiskUsage   sql.NullInt32
	CreatedAt   sql.NullTime
	UpdatedAt   sql.NullTime
	Company     string
	Hide        bool
	IsAdmin     bool
}

func (q *Queries) GetUser(ctx context.Context, login string) (GetUserRow, error) {
	row := q.db.QueryRowContext(ctx, getUser, login)
	var i GetUserRow
	err := row.Scan(
		&i.Login,
		&i.Email,
		&i.Name,
		&i.Location,
		&i.Hireable,
		&i.Blog,
		&i.Bio,
		&i.Followers,
		&i.Following,
		&i.PublicRepos,
		&i.PublicGists,
		&i.AvatarUrl,
		&i.Type,
		&i.DiskUsage,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Company,
		&i.Hide,
		&i.IsAdmin,
	)
	return i, err
}

const hideUser = `-- name: HideUser :execrows
UPDATE agg_user
SET hide = $1
WHERE login = $2
`

type HideUserParams struct {
	Hide  bool
	Login string
}

func (q *Queries) HideUser(ctx context.Context, arg HideUserParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, hideUser, arg.Hide, arg.Login)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const insertUser = `-- name: InsertUser :exec
INSERT INTO agg_user (
    login,
    email,
    name,
    location,
    hireable,
    blog,
    bio,
    followers,
    following,
    public_repos,
    public_gists,
    avatar_url,
    type,
    disk_usage,
    created_at,
    updated_at,
    refreshed_at,
    company
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9,
    $10, $11, $12, $13, $14, $15, $16, $17, $18
)
`

type InsertUserParams struct {
	Login       string
	Email       sql.NullString
	Name        sql.NullString
	Location    sql.NullString
	Hireable    sql.NullBool
	Blog        sql.NullString
	Bio         sql.NullString
	Followers   sql.NullInt32
	Following   sql.NullInt32
	PublicRepos sql.NullInt32
	PublicGists sql.NullInt32
	AvatarUrl   sql.NullString
	Type        sql.NullString
	DiskUsage   sql.NullInt32
	CreatedAt   sql.NullTime
	UpdatedAt   sql.NullTime
	RefreshedAt sql.NullTime
	Company     string
}

func (q *Queries) InsertUser(ctx context.Context, arg InsertUserParams) error {
	_, err := q.db.ExecContext(ctx, insertUser,
		arg.Login,
		arg.Email,
		arg.Name,
		arg.Location,
		arg.Hireable,
		arg.Blog,
		arg.Bio,
		arg.Followers,
		arg.Following,
		arg.PublicRepos,
		arg.PublicGists,
		arg.AvatarUrl,
		arg.Type,
		arg.DiskUsage,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.RefreshedAt,
		arg.Company,
	)
	return err
}

const popularDevs = `-- name: PopularDevs :many
SELECT
        agg_user.login,
        agg_user.name,
        agg_user.company,
        agg_user.avatar_url,
        agg_user.followers,
        agg_user.public_repos,
        repo.stars,
        repo.forks,
        agg_user.type
FROM agg_user
JOIN (
        SELECT owner, SUM(stargazers_count) AS stars, SUM(forks_count) AS forks
        FROM agg_repo
        GROUP BY owner
) AS repo ON repo.owner = agg_user.login
WHERE agg_user.type = $1
    AND agg_user.hide IS FALSE
    AND (
        $2::text IS NULL OR
        LOWER(agg_user.company) LIKE LOWER($2::text)
    )
ORDER BY repo.stars DESC
LIMIT 100
`

type PopularDevsParams struct {
	DevType        sql.NullString
	CompanyPattern sql.NullString
}

type PopularDevsRow struct {
	Login       string
	Name        sql.NullString
	Company     string
	AvatarUrl   sql.NullString
	Followers   sql.NullInt32
	PublicRepos sql.NullInt32
	Stars       int64
	Forks       int64
	Type        sql.NullString
}

func (q *Queries) PopularDevs(ctx context.Context, arg PopularDevsParams) ([]PopularDevsRow, error) {
	rows, err := q.db.QueryContext(ctx, popularDevs, arg.DevType, arg.CompanyPattern)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PopularDevsRow
	for rows.Next() {
		var i PopularDevsRow
		if err := rows.Scan(
			&i.Login,
			&i.Name,
			&i.Company,
			&i.AvatarUrl,
			&i.Followers,
			&i.PublicRepos,
			&i.Stars,
			&i.Forks,
			&i.Type,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchUsers = `-- name: SearchUsers :many
SELECT
    agg_user.login,
    agg_user.name,
    agg_user.followers,
    agg_user.public_repos,
    agg_user.public_gists,
    agg_user.avatar_url,
    agg_user.type,
    agg_user.hide,
    agg_user.is_admin,
    repo.stars,
    repo.forks
FROM agg_user
JOIN (
    SELECT owner, SUM(stargazers_count) AS stars, SUM(forks_count) AS forks
    FROM agg_repo
    GROUP BY owner
) AS repo ON repo.owner = agg_user.login
WHERE agg_user.hide IS FALSE
  AND (
    LOWER(agg_user.login) LIKE LOWER($1) OR
    LOWER(agg_user.name) LIKE LOWER($1) OR
    LOWER(agg_user.bio) LIKE LOWER($1) OR
    LOWER(agg_user.email) LIKE LOWER($1)
  )
ORDER BY repo.stars DESC
LIMIT 100
`

type SearchUsersRow struct {
	Login       string
	Name        sql.NullString
	Followers   sql.NullInt32
	PublicRepos sql.NullInt32
	PublicGists sql.NullInt32
	AvatarUrl   sql.NullString
	Type        sql.NullString
	Hide        bool
	IsAdmin     bool
	Stars       int64
	Forks       int64
}

func (q *Queries) SearchUsers(ctx context.Context, lower string) ([]SearchUsersRow, error) {
	rows, err := q.db.QueryContext(ctx, searchUsers, lower)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchUsersRow
	for rows.Next() {
		var i SearchUsersRow
		if err := rows.Scan(
			&i.Login,
			&i.Name,
			&i.Followers,
			&i.PublicRepos,
			&i.PublicGists,
			&i.AvatarUrl,
			&i.Type,
			&i.Hide,
			&i.IsAdmin,
			&i.Stars,
			&i.Forks,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateUser = `-- name: UpdateUser :execrows
UPDATE agg_user
SET
    login = $1,
    email = $2,
    name = $3,
    location = $4,
    hireable = $5,
    blog = $6,
    bio = $7,
    followers = $8,
    following = $9,
    public_repos = $10,
    public_gists = $11,
    avatar_url = $12,
    type = $13,
    disk_usage = $14,
    created_at = $15,
    updated_at = $16,
    refreshed_at = $17,
    company = $18
WHERE login = $1
`

type UpdateUserParams struct {
	Login       string
	Email       sql.NullString
	Name        sql.NullString
	Location    sql.NullString
	Hireable    sql.NullBool
	Blog        sql.NullString
	Bio         sql.NullString
	Followers   sql.NullInt32
	Following   sql.NullInt32
	PublicRepos sql.NullInt32
	PublicGists sql.NullInt32
	AvatarUrl   sql.NullString
	Type        sql.NullString
	DiskUsage   sql.NullInt32
	CreatedAt   sql.NullTime
	UpdatedAt   sql.NullTime
	RefreshedAt sql.NullTime
	Company     string
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateUser,
		arg.Login,
		arg.Email,
		arg.Name,
		arg.Location,
		arg.Hireable,
		arg.Blog,
		arg.Bio,
		arg.Followers,
		arg.Following,
		arg.PublicRepos,
		arg.PublicGists,
		arg.AvatarUrl,
		arg.Type,
		arg.DiskUsage,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.RefreshedAt,
		arg.Company,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}
