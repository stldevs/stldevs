// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: users.sql

package sqlc

import (
	"context"
	"database/sql"
)

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM agg_user
WHERE login = $1
`

func (q *Queries) DeleteUser(ctx context.Context, login string) error {
	_, err := q.db.ExecContext(ctx, deleteUser, login)
	return err
}

const getUser = `-- name: GetUser :one
SELECT
    agg_user.login,
    COALESCE(agg_user.email, '')::text AS email,
    COALESCE(agg_user.name, '')::text AS name,
    COALESCE(agg_user.location, '')::text AS location,
    COALESCE(agg_user.hireable, false)::bool AS hireable,
    COALESCE(agg_user.blog, '')::text AS blog,
    COALESCE(agg_user.bio, '')::text AS bio,
    COALESCE(agg_user.followers, 0)::int AS followers,
    COALESCE(agg_user.following, 0)::int AS following,
    COALESCE(agg_user.public_repos, 0)::int AS public_repos,
    COALESCE(agg_user.public_gists, 0)::int AS public_gists,
    COALESCE(agg_user.avatar_url, '')::text AS avatar_url,
    COALESCE(agg_user.type, '')::text AS type,
    COALESCE(agg_user.disk_usage, 0)::int AS disk_usage,
    agg_user.created_at,
    agg_user.updated_at,
    agg_user.company,
    agg_user.hide,
    agg_user.is_admin,
    COALESCE(repo.stars, 0)::int AS stars,
    COALESCE(repo.forks, 0)::int AS forks
FROM agg_user
LEFT JOIN (
        SELECT owner, SUM(stargazers_count) AS stars, SUM(forks_count) AS forks
        FROM agg_repo
        GROUP BY owner
) AS repo ON repo.owner = agg_user.login
WHERE login = $1
`

type GetUserRow struct {
	Login       string       `json:"login"`
	Email       string       `json:"email"`
	Name        string       `json:"name"`
	Location    string       `json:"location"`
	Hireable    bool         `json:"hireable"`
	Blog        string       `json:"blog"`
	Bio         string       `json:"bio"`
	Followers   int32        `json:"followers"`
	Following   int32        `json:"following"`
	PublicRepos int32        `json:"public_repos"`
	PublicGists int32        `json:"public_gists"`
	AvatarUrl   string       `json:"avatar_url"`
	Type        string       `json:"type"`
	DiskUsage   int32        `json:"disk_usage"`
	CreatedAt   sql.NullTime `json:"created_at"`
	UpdatedAt   sql.NullTime `json:"updated_at"`
	Company     string       `json:"company"`
	Hide        bool         `json:"hide"`
	IsAdmin     bool         `json:"is_admin"`
	Stars       int32        `json:"stars"`
	Forks       int32        `json:"forks"`
}

func (q *Queries) GetUser(ctx context.Context, login string) (GetUserRow, error) {
	row := q.db.QueryRowContext(ctx, getUser, login)
	var i GetUserRow
	err := row.Scan(
		&i.Login,
		&i.Email,
		&i.Name,
		&i.Location,
		&i.Hireable,
		&i.Blog,
		&i.Bio,
		&i.Followers,
		&i.Following,
		&i.PublicRepos,
		&i.PublicGists,
		&i.AvatarUrl,
		&i.Type,
		&i.DiskUsage,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Company,
		&i.Hide,
		&i.IsAdmin,
		&i.Stars,
		&i.Forks,
	)
	return i, err
}

const hideUser = `-- name: HideUser :execrows
UPDATE agg_user
SET hide = $1
WHERE login = $2
`

type HideUserParams struct {
	Hide  bool   `json:"hide"`
	Login string `json:"login"`
}

func (q *Queries) HideUser(ctx context.Context, arg HideUserParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, hideUser, arg.Hide, arg.Login)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const insertUser = `-- name: InsertUser :exec
INSERT INTO agg_user (
    login,
    email,
    name,
    location,
    hireable,
    blog,
    bio,
    followers,
    following,
    public_repos,
    public_gists,
    avatar_url,
    type,
    disk_usage,
    created_at,
    updated_at,
    refreshed_at,
    company
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9,
    $10, $11, $12, $13, $14, $15, $16, $17, $18
)
`

type InsertUserParams struct {
	Login       string         `json:"login"`
	Email       sql.NullString `json:"email"`
	Name        sql.NullString `json:"name"`
	Location    sql.NullString `json:"location"`
	Hireable    sql.NullBool   `json:"hireable"`
	Blog        sql.NullString `json:"blog"`
	Bio         sql.NullString `json:"bio"`
	Followers   sql.NullInt32  `json:"followers"`
	Following   sql.NullInt32  `json:"following"`
	PublicRepos sql.NullInt32  `json:"public_repos"`
	PublicGists sql.NullInt32  `json:"public_gists"`
	AvatarUrl   sql.NullString `json:"avatar_url"`
	Type        sql.NullString `json:"type"`
	DiskUsage   sql.NullInt32  `json:"disk_usage"`
	CreatedAt   sql.NullTime   `json:"created_at"`
	UpdatedAt   sql.NullTime   `json:"updated_at"`
	RefreshedAt sql.NullTime   `json:"refreshed_at"`
	Company     string         `json:"company"`
}

func (q *Queries) InsertUser(ctx context.Context, arg InsertUserParams) error {
	_, err := q.db.ExecContext(ctx, insertUser,
		arg.Login,
		arg.Email,
		arg.Name,
		arg.Location,
		arg.Hireable,
		arg.Blog,
		arg.Bio,
		arg.Followers,
		arg.Following,
		arg.PublicRepos,
		arg.PublicGists,
		arg.AvatarUrl,
		arg.Type,
		arg.DiskUsage,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.RefreshedAt,
		arg.Company,
	)
	return err
}

const popularDevs = `-- name: PopularDevs :many
SELECT
        agg_user.login,
        COALESCE(agg_user.name, '')::text AS name,
        agg_user.company,
        COALESCE(agg_user.avatar_url, '')::text AS avatar_url,
        COALESCE(agg_user.followers, 0)::int AS followers,
        COALESCE(agg_user.public_repos, 0)::int AS public_repos,
        repo.stars::int AS stars,
        repo.forks::int AS forks,
        COALESCE(agg_user.type, '')::text AS type
FROM agg_user
JOIN (
        SELECT owner, SUM(stargazers_count) AS stars, SUM(forks_count) AS forks
        FROM agg_repo
        GROUP BY owner
) AS repo ON repo.owner = agg_user.login
WHERE agg_user.type = $1
    AND agg_user.hide IS FALSE
    AND (
        $2::text IS NULL OR
        LOWER(agg_user.company) LIKE LOWER($2::text)
    )
ORDER BY
    CASE WHEN $3 = 'stars' THEN repo.stars END DESC,
    CASE WHEN $3 = 'forks' THEN repo.forks END DESC,
    CASE WHEN $3 = 'followers' THEN agg_user.followers END DESC,
    CASE WHEN $3 = 'public_repos' THEN agg_user.public_repos END DESC
LIMIT 100
`

type PopularDevsParams struct {
	DevType        sql.NullString `json:"dev_type"`
	CompanyPattern sql.NullString `json:"company_pattern"`
	SortBy         interface{}    `json:"sort_by"`
}

type PopularDevsRow struct {
	Login       string `json:"login"`
	Name        string `json:"name"`
	Company     string `json:"company"`
	AvatarUrl   string `json:"avatar_url"`
	Followers   int32  `json:"followers"`
	PublicRepos int32  `json:"public_repos"`
	Stars       int32  `json:"stars"`
	Forks       int32  `json:"forks"`
	Type        string `json:"type"`
}

func (q *Queries) PopularDevs(ctx context.Context, arg PopularDevsParams) ([]PopularDevsRow, error) {
	rows, err := q.db.QueryContext(ctx, popularDevs, arg.DevType, arg.CompanyPattern, arg.SortBy)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PopularDevsRow
	for rows.Next() {
		var i PopularDevsRow
		if err := rows.Scan(
			&i.Login,
			&i.Name,
			&i.Company,
			&i.AvatarUrl,
			&i.Followers,
			&i.PublicRepos,
			&i.Stars,
			&i.Forks,
			&i.Type,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchUsers = `-- name: SearchUsers :many
SELECT
    agg_user.login,
    COALESCE(agg_user.name, '')::text AS name,
    COALESCE(agg_user.followers, 0)::int AS followers,
    COALESCE(agg_user.public_repos, 0)::int AS public_repos,
    COALESCE(agg_user.public_gists, 0)::int AS public_gists,
    COALESCE(agg_user.avatar_url, '')::text AS avatar_url,
    COALESCE(agg_user.type, '')::text AS type,
    agg_user.hide,
    agg_user.is_admin,
    COALESCE(repo.stars, 0)::int AS stars,
    COALESCE(repo.forks, 0)::int AS forks
FROM agg_user
LEFT JOIN (
    SELECT owner, SUM(stargazers_count) AS stars, SUM(forks_count) AS forks
    FROM agg_repo
    GROUP BY owner
) AS repo ON repo.owner = agg_user.login
WHERE login LIKE $1
ORDER BY stars DESC
LIMIT 50
`

type SearchUsersRow struct {
	Login       string `json:"login"`
	Name        string `json:"name"`
	Followers   int32  `json:"followers"`
	PublicRepos int32  `json:"public_repos"`
	PublicGists int32  `json:"public_gists"`
	AvatarUrl   string `json:"avatar_url"`
	Type        string `json:"type"`
	Hide        bool   `json:"hide"`
	IsAdmin     bool   `json:"is_admin"`
	Stars       int32  `json:"stars"`
	Forks       int32  `json:"forks"`
}

func (q *Queries) SearchUsers(ctx context.Context, login string) ([]SearchUsersRow, error) {
	rows, err := q.db.QueryContext(ctx, searchUsers, login)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchUsersRow
	for rows.Next() {
		var i SearchUsersRow
		if err := rows.Scan(
			&i.Login,
			&i.Name,
			&i.Followers,
			&i.PublicRepos,
			&i.PublicGists,
			&i.AvatarUrl,
			&i.Type,
			&i.Hide,
			&i.IsAdmin,
			&i.Stars,
			&i.Forks,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateUser = `-- name: UpdateUser :execrows
UPDATE agg_user
SET
    login = $1,
    email = $2,
    name = $3,
    location = $4,
    hireable = $5,
    blog = $6,
    bio = $7,
    followers = $8,
    following = $9,
    public_repos = $10,
    public_gists = $11,
    avatar_url = $12,
    type = $13,
    disk_usage = $14,
    created_at = $15,
    updated_at = $16,
    refreshed_at = $17,
    company = $18
WHERE login = $1
`

type UpdateUserParams struct {
	Login       string         `json:"login"`
	Email       sql.NullString `json:"email"`
	Name        sql.NullString `json:"name"`
	Location    sql.NullString `json:"location"`
	Hireable    sql.NullBool   `json:"hireable"`
	Blog        sql.NullString `json:"blog"`
	Bio         sql.NullString `json:"bio"`
	Followers   sql.NullInt32  `json:"followers"`
	Following   sql.NullInt32  `json:"following"`
	PublicRepos sql.NullInt32  `json:"public_repos"`
	PublicGists sql.NullInt32  `json:"public_gists"`
	AvatarUrl   sql.NullString `json:"avatar_url"`
	Type        sql.NullString `json:"type"`
	DiskUsage   sql.NullInt32  `json:"disk_usage"`
	CreatedAt   sql.NullTime   `json:"created_at"`
	UpdatedAt   sql.NullTime   `json:"updated_at"`
	RefreshedAt sql.NullTime   `json:"refreshed_at"`
	Company     string         `json:"company"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateUser,
		arg.Login,
		arg.Email,
		arg.Name,
		arg.Location,
		arg.Hireable,
		arg.Blog,
		arg.Bio,
		arg.Followers,
		arg.Following,
		arg.PublicRepos,
		arg.PublicGists,
		arg.AvatarUrl,
		arg.Type,
		arg.DiskUsage,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.RefreshedAt,
		arg.Company,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}
